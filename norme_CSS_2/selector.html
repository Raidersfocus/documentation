<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
        "http://www.w3.org/TR/1999/REC-html401-19991224/loose.dtd">
<html lang="fr">

<head>
<meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-1">
<title>Les sélecteurs</title>
<link rel="stylesheet" type="text/css" href="annexe/W3C-REC.css">
<link rel="stylesheet" type="text/css" href="annexe/vf.css">
<link rel="stylesheet" type="text/css" href="annexe/print.css" media="print" > <!-- ajouté JHI 13.2.9 -->
<link rel="prev" href="syndata.html">
<link rel="next" href="cascade.html">
<link rel="contents" href="cover.html#minitoc">
<link rel="CSS-properties" href="propidx.html" title="properties">
<link rel="index" href="indexlist.html" title="index">
</head>
<body>
<!-- Préface de la traduction -->
<div id="lisezmoi">
<a href="annexe/preface.php?id=css2" title="IMPORTANT : Lisez d'abord la préface de la traduction !"><strong> Lisez-moi S.V.P. </strong></a>
</div>
<div class="navbar" align="center">
<p><a href="syndata.html">précédent</a>  
<a href="cascade.html">suivant</a>  
<a href="cover.html#minitoc">sommaire</a>  
<a href="propidx.html">propriétés</a>  
<a href="indexlist.html">index</a>  
</div>
<hr class="navbar">

<h1 align="center">5 Les sélecteurs</h1>
<div class="subtoc">
<p><strong>Contenu</strong>
  <ul class="toc">
    <li class="tocline2"><a href="selector.html#q1" class="tocxref">5.1 La reconnaissance d'un motif</a>
    <li class="tocline2"><a href="selector.html#q2" class="tocxref">5.2 La syntaxe des sélecteurs</a>
    <ul class="toc">
      <li class="tocline3"><a href="selector.html#grouping" class="tocxref">5.2.1 Le regroupement</a>
    </ul>
    <li class="tocline2"><a href="selector.html#universal-selector" class="tocxref">5.3 Le sélecteur universel</a>
    <li class="tocline2"><a href="selector.html#type-selectors" class="tocxref">5.4 Les sélecteurs de type</a>
    <li class="tocline2"><a href="selector.html#descendant-selectors" class="tocxref">5.5 Les sélecteurs descendants</a>
    <li class="tocline2"><a href="selector.html#child-selectors" class="tocxref">5.6 Les sélecteurs d'enfant</a>
    <li class="tocline2"><a href="selector.html#adjacent-selectors" class="tocxref">5.7 Les sélecteurs d'enfants adjacents</a>
    <li class="tocline2"><a href="selector.html#attribute-selectors" class="tocxref">5.8 Les sélecteurs d'attribut</a>
    <ul class="toc">
      <li class="tocline3"><a href="selector.html#q10" class="tocxref">5.8.1 La correspondance entre les attributs et leurs valeurs</a>
      <li class="tocline3"><a href="selector.html#q11" class="tocxref">5.8.2 Les valeurs par défaut des attributs dans les définitions de type de document (<abbr lang="en" title="Document Type Definition">DTD</abbr>)</a>
      <li class="tocline3"><a href="selector.html#class-html" class="tocxref">5.8.3 Les sélecteurs de classe</a>
    </ul>
    <li class="tocline2"><a href="selector.html#id-selectors" class="tocxref">5.9 Les sélecteurs d'ID</a>
    <li class="tocline2"><a href="selector.html#pseudo-elements" class="tocxref">5.10 Les pseudo-éléments et les pseudo-classes</a>
    <li class="tocline2"><a href="selector.html#q15" class="tocxref">5.11 Les pseudo-classes</a>
    <ul class="toc">
      <li class="tocline3"><a href="selector.html#first-child" class="tocxref">5.11.1 La pseudo-classe :first-child</a>
      <li class="tocline3"><a href="selector.html#link-pseudo-classes" class="tocxref">5.11.2 Les pseudo-classes d'ancre: <span class="index-def" title="pseudo-classes:::link|:link|link (pseudo-class)">:link</span> et <span class="index-def" title="pseudo-classes:::visited|:visited|visited (pseudo-class)">:visited</span></a>
      <li class="tocline3"><a href="selector.html#dynamic-pseudo-classes" class="tocxref">5.11.3 Les pseudo-classes dynamiques : <span class="index-def" title="pseudo-classes:::hover|:hover|hover (pseudo-class)">:hover</span>, <span class="index-def" title="pseudo-classes:::active|:active|active (pseudo-class)">:active</span> et <span class="index-def" title="pseudo-classes:::focus|:focus|focus (pseudo-class)">:focus</span></a>
      <li class="tocline3"><a href="selector.html#lang" class="tocxref">5.11.4 La pseudo-classe de langue : <span class="index-def" title="pseudo-classes:::lang|:lang|lang (pseudo-class)">:lang</span></a>
    </ul>
    <li class="tocline2"><a href="selector.html#q20" class="tocxref">5.12 Les pseudo-éléments</a>
    <ul class="toc">
      <li class="tocline3"><a href="selector.html#first-line-pseudo" class="tocxref">5.12.1 Le pseudo-élément <span class="index-def" title="pseudo-elements:::first-line|:first-line|first-line">:first-line</span></a>
      <li class="tocline3"><a href="selector.html#first-letter" class="tocxref">5.12.2 Le pseudo-élément <span class="index-def" title="pseudo-elements:::first-letter|:first-letter|first-letter">:first-letter</span></a>
      <li class="tocline3"><a href="selector.html#before-and-after" class="tocxref">5.12.3 Les pseudo-éléments <span class="index-def" title="pseudo-elements:::before|:before">:before</span> et <span class="index-def" title="pseudo-elements:::after|:after">:after</span></a>
    </ul>
  </ul>
</div>

<h2><a name="q1">5.1 La reconnaissance d'un motif</a></h2>

<p>
En <abbr>CSS</abbr>, des règles de reconnaissance de motifs déterminent les règles
de style qui s'appliquent aux éléments de l'<a href="conform.html#doctree">arbre du document</a>.
Ces motifs, nommés <a name="x0"><span class="index-inst" title="selector">sélecteurs</span></a>,
sont variés, allant du simple nom d'un élément jusqu'aux riches motifs contextuels.
Quand toutes les conditions d'un motif sont vérifiées pour un élément donné,
celui-ci <a name="x1"><span class="index-def" title="match|selector::match"><dfn>est retenu</dfn></span></a> par le sélecteur.

<p>
Dans un sélecteur, la sensibilité à la casse d'un nom d'élément du document dépend du langage utilisé pour le document.
Par exemple, ceux-ci sont insensibles à la casse en <abbr>HTML</abbr>, par contre, ils le sont en <abbr>XML</abbr>.

<p>
Cette table résume la syntaxe du sélecteur de <abbr>CSS2</abbr> :

<table border=1>
<tr><th>Motif<th>Signification<th>Décrit au chapitre...</tr>
<tr><td>*<td>Correspond à tout élément.<td><a href="#universal-selector">Sélecteur universel</a></tr>
<tr><td>E<td>Correspond à tout élément E (c.à.d., un élément de type E).<td><a href="#type-selectors">Sélecteurs de type</a></tr>
<tr><td>E F<td>Correspond à tout élément F qui est un descendant de l'élément E.<td><a href="#descendant-selectors">Sélecteurs descendants</a></tr>

<tr><td>E &gt; F<td>Correspond à tout élément F aussi un enfant de l'élément E.<td><a href="#child-selectors">Sélecteurs d'enfant</a></tr>
<tr><td>E:first-child<td>Correspond à un élément E aussi le premier enfant de son élément parent.<td><a href="#first-child">La pseudo-classe :first-child</a></tr>

<tr><td>E:link<br>E:visited <td>Correspond à un élément E qui est une ancre dans la source dont le lien n'a pas été visité (:link) ou bien l'a déjà été (:visited).<td><a href="#link-pseudo-classes">Les pseudo-classes de lien</a></tr>
<tr><td>E:active<br>E:hover<br>E:focus <td>Correspond à l'élément E au cours de certaines actions de l'utilisateur.<td><a href="#dynamic-pseudo-classes">Les pseudo-classes dynamiques</a>
<tr><td>E:lang(c) <td>Correspond à l'élément de type E qui emploie une langue c (la détermination de cette langue est spécifique au langage du document).<td><a href="#lang">La pseudo-classe :lang()</a>
<tr><td>E + F<td>Correspond à tout élément F immédiatement précédé par un élément E.<td><a href="#adjacent-selectors">Les sélecteurs adjacents</a></tr>
<tr><td>E[foo]<td>Correspond à tout élément E avec l'attribut "foo" (quelles qu'en soient les valeurs).<td><a href="#attribute-selectors">Sélecteurs d'attribut</a></tr>
<tr><td>E[foo="warning"]<td>Correspond à tout élément E dont l'attribut "foo" a exactement la valeur "warning".<td><a href="#attribute-selectors">Sélecteurs d'attribut</a></tr>
<tr><td>E[foo~="warning"]<td>Correspond à tout élément E dont l'attribut "foo" a pour valeur une liste de valeurs séparées par des
caractères blancs et dont une de celles-ci est "warning".<td><a href="#attribute-selectors">Sélecteurs d'attribut</a></tr>
<tr><td>E[lang|="en"]<td>Correspond à tout élément E dont l'attribut "lang" a pour valeur une liste de valeurs séparées par des tirets, cette liste commençant (à gauche) par "en".<td><a href="#attribute-selectors">Sélecteurs d'attribut</a></tr>
<tr><td>DIV.warning<td><em>Seulement en <abbr>HTML</abbr></em>. Identique à DIV[class~="warning"].<td><a href="#class-html">Sélecteurs de classe</a></tr>
<tr><td>E#myid<td>Correspond à tout élément E dont l'ID est "myid".<td><a href="#id-selectors">Sélecteurs d'ID</a></tr>
</table>


<h2><a name="q2">5.2 La syntaxe des sélecteurs</a></h2>

<p>Un <span class="index-def" title="simple selector"><a name="simple-selector"><dfn>sélecteur simple</dfn></a></span>
est soit un <a href="#type-selectors">sélecteur de type</a>, soit un <a href="#universal-selector">sélecteur universel</a>
immédiatement suivi par un <a href="#attribute-selectors">sélecteur d'attribut</a>,
un <a href="#id-selectors">sélecteur d'ID</a> ou une <a href="#pseudo-classes">pseudo-classes</a>, zéro ou plusieurs de ceux-ci, dans n'importe quel ordre.
Le sélecteur simple a une correspondance si tous ses composants sont vérifiés.

<p>Un <a name="x4"><span class="index-def" title="selector"><dfn>sélecteur</dfn></span></a> consiste en une succession
d'un, ou plusieurs, sélecteurs simples, séparés par des combinateurs.
Ces <span class="index-def" title="combinator"><a name="combinator"><dfn>combinateurs</dfn></a></span> sont :
les caractères blancs et les caractères "&gt;" et "+". Des caractères blancs peuvent être insérés entre un combinateur et ses sélecteurs simples.

<p>
Les éléments de l'arbre du document en correspondance avec un sélecteur
sont appelés <span class="index-def" title="subject (of selector)|selector::subject
of"><a name="subject"><dfn>sujets</dfn></a></span> de ce sélecteur.
Un sélecteur consistant en un seul sélecteur simple est en correspondance avec tout élément
qui satisfait à ses conditions. Quand on place un sélecteur simple avec son combinateur
au début d'une succession d'autres sélecteurs, ceci entraîne un supplément de contraintes pour la correspondance.
C'est pourquoi, les sujets d'un sélecteur forment toujours un sous-ensemble
des éléments qui correspondent au sélecteur simple situé le plus à droite.

<p>
On peut accoler un <a href="#pseudo-elements">pseudo-élément</a> au dernier sélecteur
d'une succession ; dans ce cas, l'information de style s'applique sur une partie de chacun des sujets.

<h3>5.2.1 <a name="grouping">Le regroupement</a></h3>

<p>
On peut regrouper plusieurs sélecteurs dans une liste, séparés par des virgules, quand
ceux-ci partagent les mêmes déclarations.

<div class="example"><p style="display:none">Exemple(s) :
<p>
Dans cet exemple, on condense trois règles qui ont les mêmes déclarations en une seule :

<pre>
H1 { font-family: sans-serif }
H2 { font-family: sans-serif }
H3 { font-family: sans-serif }
</pre>

<p>ceci est équivalent à :</p>

<pre>
H1, H2, H3 { font-family: sans-serif }
</pre>
</div>

<p>
CSS offre d'autres mécanismes "raccourcis" semblables, comme les <span class="index-def" title="multiple declarations"><a name="x8" href="syndata.html#declaration">déclarations multiples</a></span>
et les <span class="index-inst" title="shorthand property"><a name="x9" href="about.html#shorthand">propriétés raccourcies</a></span>.

<h2>5.3 <a name="universal-selector">Le sélecteur universel</a></h2>

<p>Le <a name="x10"><span class="index-def" title="universal selector">sélecteur universel</span></a>,
noté "*", est vérifié pour le nom de n'importe quel type d'élément. Il agit
sur chacun des éléments de l'<a href="conform.html#doctree">arbre du document</a>.

<p>
Si le sélecteur universel n'est pas le seul composant d'un <a href="#simple-selector">sélecteur simple</a>,
on peut l'omettre. Par exemple :

<ul>
<li><code>*[LANG=fr] </code> et <code>[LANG=fr]</code> sont équivalents.
<li><code>*.warning</code> et <code>.warning</code> sont équivalents.
<li><code>*#myid</code> et <code>#myid</code> sont équivalents.
</ul>

<h2>5.4 <a name="type-selectors">Les sélecteurs de type</a></h2>

<p>Un <a name="x11"><span class="index-def" title="type selector"><em>sélecteur de type</em></span></a>
correspond au nom d'un type d'élément dans le langage du document. Il correspond à chaque
instance de ce type d'élément dans l'arbre du document.

<div class="example"><p style="display:none">Exemple(s) :</p>
<p>
La règle suivante concerne tous les éléments H1 d'un arbre :

<pre>
H1 { font-family: sans-serif }
</pre>
</div>

<h2>5.5 <a name="descendant-selectors">Les sélecteurs descendants</a></h2>

<p>
Un auteur peut vouloir disposer d'un sélecteur pour atteindre un élément donné,
celui-ci étant lui-même un descendant d'un autre élément de l'arbre du
document (ex. "Toucher ces éléments EM qui sont dans un élément H1").
Les <a name="x12"><span class="index-def" title="descendant-selectors">sélecteurs descendants</span></a>
sont l'expression de cette relation dans un motif. Ceux-ci se composent de deux sélecteurs, ou plus,
séparés par un <a href="syndata.html#whitespace">caractère blanc</a>.
Un sélecteur descendant de la forme "<code>A B</code>" se vérifie quand un élément
<code>B</code> est un descendant arbitraire d'un élément <code>A</code>, son <a href="conform.html#doctree">ancêtre</a>.

<div class="example"><p style="display:none">Exemple(s) :</p><p>
Considérons par exemple les règles suivantes :</p>

<pre>
H1 { color: red }
EM { color: red }
</pre>

<p>
Bien que l'intention ait pu être l'emphase d'un texte en changeant sa couleur, l'effet sera perdu
dans ce cas-ci :

<pre class="html-example">
&lt;H1&gt;Ce titre est &lt;EM&gt;très&lt;/EM&gt; important&lt;/H1&gt;
</pre>

<p>
Nous tenons compte de cette éventualité en ajoutant une règle au jeu précédent,
celle-ci fixe une couleur bleu au texte d'un élément EM survenant dans
un élément H1 :

<pre>
H1 { color: red }
EM { color: red }
H1 EM { color: blue }
</pre>

<p>
La troisième règle s'appliquera à l'élément EM de cet extrait-ci :

<pre class="html-example">
&lt;H1&gt;Ce &lt;SPAN class="myclass"&gt;titre 
est &lt;EM&gt;très&lt;/EM&gt; important.&lt;/SPAN&gt;&lt;/H1&gt;
</pre>
</div>

<div class="example"><p style="display:none">Exemple(s) :</p><p>
Avec ce sélecteur :</p>

<pre>
DIV * P 
</pre>

<p>
on touche les éléments P qui sont les petits-enfants, ou les descendants plus lointains,
d'un élément DIV. Noter les caractères blancs <ins title="id=x55">facultatifs</ins> de chaque côté du "*".
</div>

<div class="example"><p style="display:none">Exemple(s) :
<p>
Dans cette règle suivante, on a une combinaison de sélecteur descendant et de <a href="#attribute-selectors">sélecteur d'attribut</a>,
celle-ci concerne les éléments qui, à la fois, (1) ont un attribut "href" et (2) sont
contenus dans un élément P lui-même dans un élément DIV :

<pre>
DIV P *[href]
</pre>
</div>

<h2>5.6 <a name="child-selectors">Les sélecteurs d'enfant</a></h2>

<p>Un <a name="x13"><span class="index-def" title="child selector"><em>sélecteur d'enfant</em></span></a>
se vérifie quand un élément est l'<a href="conform.html#doctree">enfant</a> d'un autre élément.
Celui-ci se compose de deux sélecteurs, ou plus, séparés par le caractère "&gt;".

<div class="example"><p style="display:none">Exemple(s) :
<p>
La règle suivante applique un style à tous les enfants P de l'élément BODY :

<pre>
BODY &gt; P { line-height: 1.3 }
</pre>
</div>

<div class="example"><p style="display:none">Exemple(s) :
<p>
Dans cet exemple-ci, on a combiné un sélecteur descendant et un sélecteur d'enfant :

<pre>
DIV OL&gt;LI P
</pre>

<p>
Cette règle concerne tout élément P qui est un descendant d'un élément LI,
celui-ci devant être l'enfant d'un élément OL qui, à son tour, doit être
un descendant de l'élément DIV. Noter l'absence de caractères blancs, facultatifs, autour de la
combinateur "&gt;".
</div>

<p>
Pour des renseignements sur la façon de sélectionner le premier enfant d'un élément,
voir le chapitre sur la pseudo-classe <a href="#first-child">:first-child</a> plus loin.

<h2>5.7 <a name="adjacent-selectors">Les sélecteurs d'enfants adjacents</a></h2>

<p>
Les sélecteurs d'enfants adjacents suivent une syntaxe de cette forme : E1 + E2, où E2 est
le sujet du sélecteur. Celui-ci est vérifié quand E1 et E2 ont le même parent
dans l'arbre du document et quand E1 y précède immédiatement E2.

<p>
Selon le contexte, les éléments adjacents génèrent un formatage des
objets dont la mise en forme est gérée automatiquement (ex. les marges verticales
des boîtes adjacentes qui fusionnent). Avec le combinateur "+", les auteurs peuvent ajouter des styles
aux éléments adjacents.

<div class="example"><p style="display:none">Exemple(s) :
<p>
En exemple, cette règle précise qu'un élément P qui suit un élément
MATH ne devrait pas avoir d'alinéa :

<pre>
MATH + P { text-indent: 0 } 
</pre>

<p>
Le suivant produit une réduction de l'espace vertical entre un élément H1 et l'élément
H2 qui le suit juste après :

<pre>
H1 + H2 { margin-top: -5mm }   
</pre>
</div>

<div class="example"><p style="display:none">Exemple(s) :
<p> 
Ici, la règle est similaire à la précédente, à la différence
qu'elle comporte un sélecteur d'attribut en plus. Ainsi, une mise en forme particulière
s'applique aux éléments H1 avec un attribut <samp>class="opener"</samp> :

<pre>
H1.opener + H2 { margin-top: -5mm }   
</pre>
</div>

<h2>5.8 <a name="attribute-selectors">Les sélecteurs d'attribut</a></h2>

<p>
Avec <abbr>CSS2</abbr>, on peut spécifier des règles qui s'applique aux attributs définis dans
le document source.

<h3><a name="q10">5.8.1 La correspondance entre les attributs et leurs valeurs</a></h3>

<p>
Les sélecteurs d'attribut peuvent trouver une correspondance de quatre façons :

<dl>
<dt><code>[att]</code>
<dd>Quand un élément a un attribut "att", quelle que soit sa valeur ;
<dt><a name="x14"><span class="index-def" title="exact matching|="><code>[att=val]</code></span></a>
<dd>Quand un élément a un attribut "att" dont la valeur est exactement "val" ;
<dt><a name="x16"><span class="index-def" title="space-separated matching|~="><code>[att~=val]</code></span></a>
<dd>Quand un élément avec un attribut "att" qui admet comme valeur une suite de valeurs séparées par des caractères blancs, une des valeurs est exactement "val".
Avec ce sélecteur, les valeurs de la liste ne doivent pas contenir de caractères blancs (car ceux-ci font déjà office de séparateurs) ;

<dt><a name="x18"><span class="index-def" title="hyphen-separated matching|&#124;="><code>[att|=val]</code></span></a>
<dd>Quand un élément avec un attribut "att" qui admet comme valeur une suite de valeurs séparées par des tirets, la première valeur est "val".
La correspondance intervient toujours au début de la valeur de l'attribut.
Ceci, principalement, pour permettre une correspondance sur les <a name="x20"><span class="index-inst" title="language code">sous-codes des langues</span></a>
qui sont décrits dans RFC 1766 (<a href="refs.html#ref-RFC1766" rel="biblioentry" class="noxref"><span class="informref">[RFC1766]</span></a>).
</dl>

<p>
Les valeurs d'attribut doivent être des identificateurs ou des chaînes. La sensibilité
à la casse des noms et des valeurs d'attributs dans les sélecteurs dépendent du langage du document.

<div class="example"><p style="display:none">Exemple(s) :
<p>
Par exemple, ce sélecteur d'attribut correspond avec ceux des éléments
H1 qui ont un attribut "title", quelle que soit sa valeur :

<pre>
H1[title] { color: blue; }
</pre>
</div>

<div class="example"><p style="display:none">Exemple(s) :
<p>
Dans cet exemple, le sélecteur correspond avec tous les éléments
SPAN dont la valeur de l'attribut "class" est exactement "exemple" :

<pre>
SPAN[class=exemple] { color: blue; }
</pre>
</div>

<p>
On peut utiliser plusieurs sélecteurs d'attribut qui se réfèrent
à plusieurs attributs d'un élément, ou même, plusieurs fois au
même attribut.

<div class="example"><p style="display:none">Exemple(s) :
<p>
Ici, le sélecteur correspond avec tous les éléments SPAN dont l'attribut
"bonjour" a exactement la valeur "soleil" et l'attribut "adieu" exactement la valeur "nuages" :

<pre>
SPAN[bonjour="soleil"][adieu="nuages"] { color: blue; }
</pre>
</div>

<div class="example"><p style="display:none">Exemple(s) :
<p>
Les sélecteurs suivants illustrent la différence entre "=" et "~=".
Le premier sera vérifié pour, en exemple, la valeur "copyright copyleft copyeditor" de l'attribut "rel".
Le second uniquement quand l'attribut "href" aura la valeur "http://www.w3.org/".

<pre>
A[rel~="copyright"]
A[href="http://www.w3.org/"]
</pre>
</div>

<div class="example"><p style="display:none">Exemple(s) :
<p>
La règle suivante cache tous les éléments dont la valeur de l'attribut "lang" est
"fr" (c.à.d. en langue française).

<pre>
*[LANG=fr] { display : none }
</pre>
</div>

<div class="example"><p style="display:none">Exemple(s) :
<p>
Cette règle-ci sera vérifiée pour les valeurs de l'attribut "lang" qui commence
par "en", y inclus "en", "en-US" et "en-cockney" :

<pre>
*[LANG|="en"] { color : red }
</pre>
</div>

<div class="example"><p style="display:none">Exemple(s) :
<p>
De la même façon, la feuille de style auditive ci-dessous permet la lecture d'un dialogue
avec des voix différentes pour chaque personnage :

<pre class="example">
DIALOGUE[character=romeo] 
     { voice-family: "Lawrence Olivier", charles, male }
      
DIALOGUE[character=juliet]  
     { voice-family: "Vivien Leigh", victoria, female }
</pre>
</div>

<h3><a name="q11">5.8.2 Les valeurs par défaut des attributs dans les définitions de type de document (<abbr lang="en" title="Document Type Definition">DTD</abbr>)</a></h3>

<p>
La correspondance se fait sur les valeurs d'attributs dans l'arbre du document. Pour des langages
de document autres que <abbr>HTML</abbr>, les valeurs par défaut des attributs peuvent être définies
dans un <a name="x21"><span class="index-inst" title="DTD"><abbr>DTD</abbr></span></a> ou ailleurs. Les feuilles de
style devraient être construites pour fonctionner même si les valeurs par défaut n'étaient
pas inclues dans l'arbre du document.

<div class="example"><p style="display:none">Exemple(s) :
<p>
Considérons, par exemple, un élément EXEMPLE avec un attribut "notation" et sa valeur
par défaut "decimal". L'extrait du <abbr>DTD</abbr> pourrait être :

<pre class="dtd-example">
&lt;!ATTLIST EXEMPLE notation (decimal,octal) "decimal"&gt;
</pre>

<p>Si la feuille de style contient les règles :

<pre class="example">
EXEMPLE[notation=decimal] { /*... paramètres par défaut des propriétés ...*/ }
EXEMPLE[notation=octal] { /*... autres paramètres ...*/ }
</pre>

<p>alors, pour les cas où l'attribut a une valeur par défaut,
non fixé explicitement, il faudrait rajouter cette règle-ci :

<pre class="example">
EXAMPLE { /*... paramètres par défaut de la propriété ...*/ }
</pre>

<p>
Ce sélecteur étant moins <a href="cascade.html#specificity">spécifique</a> qu'un 
sélecteur d'attribut, celui-ci ne sera employé que dans les situations par défaut.
Il faudra tenir compte explicitement de toutes les autres valeurs d'attribut qui ne doivent pas recevoir
le même style que le défaut.
</div>

<h3>5.8.3 <a name="class-html">Les sélecteurs de classe</a></h3> 

<p>
Pour les feuilles de style employées avec <abbr>HTML</abbr>, les auteurs, visant l'attribut "class",
peuvent utiliser la notation avec un point (.) en remplacement de celle avec "~=".
Ainsi, "DIV.valeur" et "DIV[class~=valeur]" ont la même signification en <abbr>HTML</abbr>. La valeur de
l'attribut doit suivre immédiatement le caractère ".".

<div class="example"><p style="display:none">Exemple(s) :
<p>
Par exemple, on peut appliquer un style à ceux des élément avec l'attribut
<samp>class~="pastoral"</samp>, comme suit :

<pre>
*.pastoral { color: green }  /* tous les éléments avec class~=pastoral */
</pre>

ou simplement avec :

<pre>
.pastoral { color: green }  /* tous les éléments avec class~=pastoral */
</pre>

<p>
Dans ce qui suit, on applique seulement le style aux éléments H1 avec l'attribut
<samp>class~="pastoral"</samp> :

<pre>
H1.pastoral { color: green }  /* les éléments H1 avec class~=pastoral */
</pre>

<p>
Selon ces règles, le premier élément H1 n'aurait pas son texte en vert,
contrairement au second :

<pre>
&lt;H1&gt;Pas vert&lt;/H1&gt;
&lt;H1 class="pastoral"&gt;Vraiment vert&lt;/H1&gt;
</pre>
</div>

<p>
Pour une correspondance sur un sous-ensemble des valeurs de "class", chacune des valeurs doit être
précédée par un ".", dans n'importe quel ordre.

<div class="example"><p style="display:none">Exemple(s) :
<p>
Par exemple, cette règle suivante est vérifiée pour chacun des éléments P
dont la valeur de l'attribut "class" est constituée d'une suite de valeurs séparées
par des caractères blancs, parmi celles-ci "pastoral" et "marine" :

<pre> 
P.pastoral.marine { color: green }
</pre>

<p>
La règle est appliquée pour une valeur <samp>class="pastoral blue aqua marine"</samp>,
mais pas pour <samp>class="pastoral blue"</samp>.
</div>

<div class="note"><p> <em><strong>Remarque : </strong>
Avec une telle importance donnée par <abbr>CSS</abbr> à l'attribut "class", les auteurs pourraient
presque construire leur propre "langage de document" en partant d'éléments qui ont
une faible vocation de présentation (comme DIV et SPAN en <abbr>HTML</abbr>) et en leur appliquant un style
via cet attribut. Les auteurs devraient éviter une telle pratique car les significations des éléments
de structure d'un langage de document sont reconnues et acceptées, celles des classes définies par un auteur
risquant de ne pas l'être.</em>
</div>

<h2>5.9 <a name="id-selectors">Les sélecteurs d'ID</a></h2>

<p>
Les langages de document peuvent contenir des attributs déclarés de type ID.
Ceux-ci sont particuliers dans la mesure où il ne peut y avoir deux de ces attributs avec une
même valeur ; quel que soit le langage du document, un attribut ID sert à identifier un
élément unique. En <abbr>HTML</abbr>, les attributs ID sont représentés par "id" ; en
<abbr>XML</abbr>, les applications peuvent utiliser d'autres noms pour ceux-ci, mais avec les mêmes restrictions.

<p>
Les auteurs peuvent utiliser l'attribut ID d'un langage donné pour identifier une instance d'un
élément dans l'arbre du document. Un sélecteur d'ID de <abbr>CSS</abbr> correspond
avec un tel élément au travers de l'identificateur qui lui est assigné. Ce sélecteur
est formé du caractère "#" immédiatement suivi par la valeur de l'ID.

<div class="example"><p style="display:none">Exemple(s) :
<p> 
Le sélecteur d'ID suivant correspond à l'élément H1 dont la valeur de l'attribut
ID est "chapitre1" :

<pre>
H1#chapitre1 { text-align: center }
</pre>
</div>

<div class="html-example"><p> 
Dans cet exemple, la règle s'applique à l'élément avec un ID dont la valeur
est "z98y". Il s'agit de l'élément P :

<pre>
&lt;HEAD&gt;
  &lt;TITLE&gt;Toucher P&lt;/TITLE&gt;
  &lt;STYLE type="text/css"&gt;
    *#z98y { letter-spacing: 0.3em }
  &lt;/STYLE&gt;
&lt;/HEAD&gt;
&lt;BODY&gt;
   &lt;P id=z98y&gt;Un texte élargi&lt;/P&gt;
&lt;/BODY&gt;
</pre>

<p>
Par contre, dans celui-ci, la règle s'applique seulement à un élément H1
avec un ID dont la valeur est "z98y". Ici, l'élément P ne sera pas concerné :

<pre>
&lt;HEAD&gt;
  &lt;TITLE&gt;Touche seulement H1&lt;/TITLE&gt;
  &lt;STYLE type="text/css"&gt;
    H1#z98y { letter-spacing: 0.5em }
  &lt;/STYLE&gt;
&lt;/HEAD&gt;
&lt;BODY&gt;
   &lt;P id=z98y&gt;Un texte élargi&lt;/P&gt;
&lt;/BODY&gt;
</pre>
</div>

<p>
Les sélecteurs d'ID ont une plus grande <del title="id=x56">priorité</del> <ins title="id=x56">spécificité</ins>
que les sélecteurs d'attribut. En <abbr>HTML</abbr>, par exemple, le sélecteur <samp>#p123</samp> est plus spécifique
que le sélecteur <samp>[ID=p123]</samp>, compte tenu de la <a href="cascade.html">cascade</a>.

<div class="note">
<p><em><strong>Remarque : </strong>
En <abbr>XML 1.0</abbr> <a href="refs.html#ref-XML10" rel="biblioentry" class="noxref"><span class="informref">[XML10]</span></a>,
c'est dans un <abbr>DTD</abbr> que l'on répertorie les attributs qui contiennent les IDs des éléments.
Au moment d'interpréter un document <abbr>XML</abbr>, les agents utilisateurs ne lisant pas toujours le <abbr>DTD</abbr>,
ceux-ci risquent de ne pas connaître l'ID d'un élément. Un auteur qui sait ou suspecte cette possibilité
devrait employer un sélecteur d'attribut normal : <code>[name=p371]</code> plutôt que <code>#p371</code>.
Comme l'ordre de cascade diffère selon qu'on emploie un sélecteur d'attribut ou un sélecteur d'ID,
il peut être nécessaire de compléter les déclarations avec une priorité 
"!important" : <code>[name=p371] {color: red !important}</code>. Bien entendu, dans un document <abbr>XML 1.0</abbr> sans <abbr>DTD</abbr>,
les éléments n'ont pas du tout d'IDs.</em>
</div>

<h2>5.10 <a name="pseudo-elements">Les pseudo-éléments</a> et les <a name="pseudo-classes">pseudo-classes</a></h2>

<p>
En <abbr>CSS2</abbr>, le style est habituellement lié à un élément selon sa position dans
l'<a href="conform.html#doctree">arbre du document</a>. Ce modèle simple est suffisant
la plupart du temps, mais du fait de la structure de cet <a href="conform.html#doctree">arbre</a>,
n'est pas adapté dans certains contextes usuels de publication. Par exemple, en <abbr>HTML 4.0</abbr>
(voir <a href="refs.html#ref-HTML40" rel="biblioentry" class="noxref"><span class="normref">[HTML40]</span></a>),
il n'existe pas d'éléments qui se réfèrent à la première ligne
d'un paragraphe, et donc aucun sélecteur simple en <abbr>CSS</abbr> ne peut y correspondre.

<p>
C'est pourquoi <abbr>CSS</abbr> introduit les concepts de <a name="x22"><span class="index-def" title="pseudo-elements"><dfn>pseudo-éléments</dfn></span></a>
et de <a name="x23"><span class="index-def" title="pseudo-classes"><dfn>pseudo-classes</dfn></span></a>
ce qui permet une mise en forme à partir d'informations absentes de l'arbre du document.

<ul>
<li>
Les pseudo-éléments créent des abstractions dans l'arbre en plus
des éléments déjà spécifiés par le langage du document.
Ainsi, certains langages n'offrent pas de mécanismes de correspondance avec la première
lettre ou la première ligne du contenu d'un élément. Les pseudo-éléments
de <abbr>CSS</abbr> permettent aux auteurs d'y accéder, ce qui serait autrement impossible. Ces pseudo-éléments
leur permettent de donner un style à un contenu qui n'apparaît même pas dans le document
source. Par exemple, les pseudo-éléments <a href="generate.html#before-after-content">:before et :after</a>
autorisent une action sur un contenu généré.

<li>
Les pseudo-classes classent les éléments selon des caractéristiques autres que leur
nom, attribut ou contenu, celles-ci ne pouvant pas en principe être déduites de l'arbre
du document. Les pseudo-classes peuvent être dynamiques, dans le sens où un élément
peut les acquérir ou les perdre pendant l'interaction de l'utilisateur avec le document.
Une exception, la pseudo-classe <a href="#first-child">':first-child'</a>, qui <em>peut</em> se déduire de l'arbre.
<span><ins title="id=x7">Dans certains cas, la pseudo-classe ':lang()' peut également se déduire du document.</ins></span>
</ul>

<p>
Ni les pseudo-éléments, ni les pseudo-classes n'apparaissent dans la source ou l'arbre du document.

<p>
Les pseudo-classes sont autorisées n'importe où dans le sélecteur, alors qu'un pseudo-élément ne peut être
spécifié qu'après le <a href="#subject">sujet</a> du sélecteur.

<p>
Les pseudo-éléments et pseudo-classes sont insensibles à la casse.

<p>
Certaines pseudo-classes s'excluent mutuellement, d'autres peuvent s'appliquer simultanément
au même élément. Les conflits éventuels se résolvent selon
l'<a href="cascade.html#cascading-order">ordre normal de cascade</a>.

<p>
Les <a href="conform.html#conformance">agents utilisateurs conformes à <abbr>HTML</abbr></a> peuvent
<span class="index-inst" title="ignore"><a name="x24" href="syndata.html#ignore">ignorer</a></span>
toutes les règles dont les sélecteurs comportent des pseudo-éléments :first-line ou :first-letter,
ou, sinon, peuvent n'appliquer qu'une partie de leurs propriétés.

<h2><a name="q15">5.11 Les pseudo-classes</a></h2>

<h3>5.11.1 La pseudo-classe <a name="first-child">:first-child</a></h3>

<p>La pseudo-classe <a name="x25"><span class="index-def" title="first-child|:first-child">:first-child</span></a>
correspond au premier élément enfant d'un autre élément.

<div class="example"><p style="display:none">Exemple(s) :
<p>
Dans l'exemple suivant, le sélecteur désigne chacun des éléments P qui
soit le premier enfant d'un élément DIV. La règle supprime l'alinéa du
premier paragraphe d'un élément DIV :

<pre>
DIV &gt; P:first-child { text-indent: 0 }
</pre>

Dans l'extrait suivant, ce même sélecteur viserait l'élément P dans l'élément DIV :

<pre class="html-example">
&lt;P&gt; Le dernier P avant la note.
&lt;DIV class="note"&gt;
   &lt;P&gt; Le premier P à l'intérieur de la note.
&lt;/DIV&gt;
</pre>

mais, dans cet extrait-ci, il ne toucherait pas le second élément P :

<pre class="html-example">
&lt;P&gt; Le dernier P avant la note.
&lt;DIV class="note"&gt;
   &lt;H2&gt;Note&lt;/H2&gt;
   &lt;P&gt; Le premier P à l'intérieur de la note.
&lt;/DIV&gt;
</pre>
</div>

<div class="example"><p style="display:none">Exemple(s) :

<p>
La règle suivante applique un style de texte gras à chacun des élément EM
descendants d'un élément P, celui-ci étant un premier enfant :

<pre>
P:first-child EM { font-weight : bold }
</pre>
</div>

<p>
Noter que les boîtes <a href="visuren.html#anonymous">anonymes</a> n'apparaissent pas dans
l'arbre du document, c'est pourquoi elles ne sont pas prises en compte au moment de la mise
en forme du premier enfant.

<div class="html-example">
<p>
Par exemple, l'élément EM qui est dans :

<pre>
&lt;P&gt;abc &lt;EM&gt;défaut&lt;/EM&gt; 
</pre>

celui-ci est le premier enfant de l'élément P.
</div>

<p>
Les deux sélecteurs suivants sont équivalents :

<pre>
* &gt; A:first-child   /* A est le premier enfant pour tout élément */
A:first-child       /* Idem */
</pre>


<h3>5.11.2 <a name="link-pseudo-classes">Les pseudo-classes d'ancre</a> : <a name="x27"><span class="index-def" title="pseudo-classes:::link|:link|link (pseudo-class)">:link</span></a> et <a name="x30"><span class="index-def" title="pseudo-classes:::visited|:visited|visited (pseudo-class)">:visited</span></a></h3>

<p>
En général, les agents utilisateurs représentent différemment les liens
qui n'ont pas été visités de ceux qui l'ont déjà été.
CSS en fournit un équivalent au travers des pseudo-classes ':link' et ':visited'.

<ul>
<li> La pseudo-classe :link s'applique aux liens qui n'ont pas été visités ;

<li> La pseudo-classe :visited s'applique lorsque le lien a été visité par l'utilisateur.
</ul>

<p class="note"><em><strong>Remarque : </strong>
Après un certain temps, les agents utilisateurs peuvent revenir de l'état visité
à l'état non-visité du lien.</em>

<p>
Ces deux états s'excluent mutuellement.

<p>
Le langage du document détermine quelles ancres ont des sources hyperliens. Ainsi en <abbr>HTML 4.0</abbr>,
les pseudo-classes d'ancre s'appliquent aux éléments A avec un attribut "href".
Les deux déclarations <abbr>CSS2</abbr> suivantes produisent le même effet :

<pre>
A:link { color: red }
:link  { color: red }
</pre>

<div class="example"><p style="display:none">Exemple(s) :
<p>
Pour ce lien :

<pre class="html-example">
&lt;A class="external" href="http://out.side/"&gt;lien externe&lt;/A&gt;
</pre>

si celui est visité, la règle suivante :

<pre>
A.external:visited { color: blue }
</pre>

celle-ci rendra bleue la couleur du lien.
</div>

<h3>5.11.3 <a name="dynamic-pseudo-classes">Les pseudo-classes dynamiques :</a> <a name="x33"><span class="index-def" title="pseudo-classes:::hover|:hover|hover (pseudo-class)">:hover</span></a>, <a name="x36"><span class="index-def" title="pseudo-classes:::active|:active|active (pseudo-class)">:active</span></a> et <a name="x39"><span class="index-def" title="pseudo-classes:::focus|:focus|focus (pseudo-class)">:focus</span></a></h3>

<p>
Les agents utilisateurs interactifs changent parfois l'aspect du rendu en réponse aux actions de l'utilisateur.
<abbr>CSS2</abbr> propose trois pseudo-classes pour un usage courant :

<ul>
<li> La pseudo-classe :hover, qui est appliquée quand l'utilisateur désigne un élément
(au moyen d'un appareil de pointage) sans l'activer. Par exemple, un agent utilisateur visuel pourrait
appliquer celle-ci quand le pointeur (d'une souris) survole la boîte produite par un élément.
Les agents utilisateurs qui n'ont pas de capacités <a href="media.html#interactive-media-group">interactives</a>
ne sont pas tenus d'appliquer cette pseudo-classe. Certains agents utilisateurs conformes dotés
de ces capacités <a href="media.html#interactive-media-group">interactives</a> peuvent être
incapables de l'appliquer (ex. un crayon optique) ;

<li> La pseudo-classe :active, qui est appliquée quand l'utilisateur active un élément.
Par exemple, entre le moment où l'utilisateur presse le bouton de la souris et le relâche.

<li> La pseudo-classe :focus, qui s'applique quand un élément reçoit l'attention
(celui-ci acceptant les événements du clavier ou d'autres formes d'entrées de texte).
</ul>

<p>
Ces pseudo-classes ne s'excluent pas mutuellement. Un élément peut correspondre à
plusieurs d'entre elles au même moment.

<p>
CSS ne définit pas lesquels des éléments peuvent être dans un de ces états
ou comment ceux-ci entrent et sortent de ces états. L'écriture peut varier, selon que
les éléments réagissent aux actions de l'utilisateur, ou non ; les divers
appareils et agents utilisateurs peuvent avoir différentes façons de désigner ou d'activer
les éléments.

<p>
Les agents utilisateurs ne sont pas tenus, en raison des transitions provoquées par les pseudo-classes,
de remettre en forme le document en cours d'affichage. Par exemple, une feuille de style peut spécifier
que la taille de la police (<a href="fonts.html#propdef-font-size" class="noxref"><span class="propinst-font-size">'font-size'</span></a>)
d'un lien sous l'effet de la pseudo-classe :active soit plus grande que celle d'un lien inactif, et un agent utilisateur,
comme cela peut modifier la position des lettres, peut en ignorer la règle.

<div class="example"><p style="display:none">Exemple(s) :
<p>

<pre>
A:link    { color: red }    /* lien non-visité */
A:visited { color: blue }   /* lien visité   */
A:hover   { color: yellow } /* lien survolé     */
A:active  { color: lime }   /* lien activé    */
</pre>

<p>
Noter que la règle A:hover doit être placé après A:link et A:visited,
autrement les règles de cascade feront que la propriété <a href="colors.html#propdef-color" class="noxref"><span class="propinst-color">'color'</span></a>
spécifiée par celle-ci sera cachée. De la même façon, comme la règle
A:active est placée après A:hover, la couleur spécifiée par celle-ci (lime) sera
appliquée quand l'utilisateur active et survole l'élément A.
</div>

<div class="example"><p style="display:none">Exemple(s) :

<p>
Voici un exemple de combinaison de pseudo-classes dynamiques :

<pre>
A:focus { background: yellow }
A:focus:hover { background: white }
</pre>

<p>
Le dernier sélecteur correspond à un élément A qui a l'attention et qui est
survolé.

</div>

<p>
Au sujet de la représentation des contours de l'objet qui a l'attention, consulter le chapitre
sur les <a href="ui.html#dynamic-outlines">contours dynamiques pour l'attention</a>.

<div class="note"><p>
<em><strong>Remarque : </strong>
En CSS1, la pseudo-classe ':active' et les pseudo-classes ':link' et ':visited' s'excluaient mutuellement.
Ce n'est plus le cas. Un élément peut correspondre aux pseudo-classes ':visited' et ':active'
(ou ':link' et ':active'), les règles normales de cascade déterminant lesquelles des
propriétés s'appliquent.</em>
</div>

<h3>5.11.4 <a name="lang">La pseudo-classe de langue :</a> <a name="x42"><span class="index-def" title="pseudo-classes:::lang|:lang|lang (pseudo-class)">:lang</span></a></h3>

<p>
Quand le langage du document spécifie une manière de déterminer le
<a name="x45"><span class="index-inst" title="language (human)">langage humain</span></a> d'un élément,
on peut écrire des sélecteurs <abbr>CSS</abbr> pour viser un élément selon la langue
que celui-ci emploie. Par exemple en <abbr>HTML</abbr> <a href="refs.html#ref-HTML40" rel="biblioentry" class="noxref"><span class="normref">[HTML40]</span></a>,
on peut déterminer la langue employée en combinant l'attribut "lang", l'élément META
et, d'une certaine façon, des informations issues du protocole (tel que les entêtes HTTP).
En <abbr>XML</abbr>, on utilise un attribut nommé <del title="id=x32">XML:LANG</del> <ins title="id=x32">xml:lang</ins>,
d'autres méthodes de détermination spécifiques au langage d'un document pouvant exister.

<p>
La pseudo-classe ':lang(C)' est vérifiée pour un élément dans la langue C.
La lettre C représente un <a name="x46"><span class="index-inst" title="language code">code de langue</span></a>
tel que spécifié dans <abbr>HTML 4.0</abbr> <a href="refs.html#ref-HTML40" rel="biblioentry" class="noxref"><span class="normref">[HTML40]</span></a>
et RFC 1766 <a href="refs.html#ref-RFC1766" rel="biblioentry" class="noxref"><span class="informref">[RFC1766]</span></a>.
La correspondance s'effectue de la même façon que pour l'<a href="#attribute-selectors">opérateur '|='</a>.

<div class="example"><p style="display:none">Exemple(s) :

<p>
Les règles suivantes fournissent les marques de citations pour un document <abbr>HTML</abbr>, selon que celui-ci
est en français ou en allemand :

<pre>
HTML:lang(fr) { quotes: '« ' ' »' }
HTML:lang(de) { quotes: '&raquo;' '&laquo;' '\2039' '\203A' }
:lang(fr) &gt; Q { quotes: '« ' ' »' }
:lang(de) &gt; Q { quotes: '&raquo;' '&laquo;' '\2039' '\203A' }
</pre>

<p>
La seconde paire de règles applique en fait la propriété <a href="generate.html#propdef-quotes" class="noxref"><span class="propinst-quotes">'quotes'</span></a>
aux éléments Q, en fonction de la langue du parent. Ceci pour tenir compte du choix des marques
de citations, celles-ci dépendent typiquement de la langue employée par l'élément
qui les contient et non de la citation elle-même. Par exemple, cet extrait anglais « by surprise »
(et non &#8220;by surprise&#8221;) cité au milieu d'un texte français.
</div>

<h2><a name="q20">5.12 Les pseudo-éléments</a></h2>

<h3>5.12.1 Le pseudo-élément <span class="index-def" title="pseudo-elements:::first-line|:first-line|first-line"><a name="first-line-pseudo">:first-line</a></span></h3>

<p>
Le pseudo-élément :first-line produit un style particulier sur la première ligne
formatée d'un paragraphe. Par exemple :

<pre class="example">
P:first-line { text-transform: uppercase }
</pre>

<p>
La règle précédente signifie "mettre les lettres de la première ligne de
chaque paragraphe en majuscule". Cependant, le sélecteur "P:first-line" ne correspond à
aucun élément <abbr>HTML</abbr> réel. Celui-ci correspond en fait à un pseudo-élément
que l'<a href="conform.html#conformance">agent utilisateur conforme</a> va insérer au début
de chaque paragraphe.

<p>
Noter que la longueur de la première ligne dépend de plusieurs facteurs, dont la largeur
de la page, la taille de la police, etc. Ainsi un paragraphe quelconque en <abbr>HTML</abbr> tel que :

<pre class="html-example">
&lt;P&gt;Voici un paragraphe HTML plutôt 
long qui va être découpé en plusieurs 
lignes. La première ligne sera identifiée
à l'aide d'une séquence de balises fictives. 
Les autres lignes vont rester ordinaires 
dans la suite du paragraphe.&lt;/P&gt;
</pre>

Celui-ci va apparaître avec le découpage des lignes suivant :

<pre class="html-example">
VOICI UN PARAGRAPHE HTML PLUTÔT LONG
qui va être découpé en plusieurs lignes.
La première ligne sera identifiée à
l'aide d'une séquence de balises fictives. 
Les autres lignes vont rester ordinaires
dans la suite du paragraphe.
</pre>

Un agent utilisateur pourrait le "récrire" et y inclure la <em><a name="x50"><span class="index-def" title="fictional tag sequence">séquence de balises fictives</span></a></em>
pour le pseudo-élément :first-line. Cette séquence fictive aide à
représenter comment les propriété sont héritées.

<pre>
&lt;P&gt;<b>&lt;P:first-line&gt;</b>Voici un paragraphe HTML plutôt
long <del title="id=x33">qui</del> <b>&lt;/P:first-line&gt;</b><ins title="id=x33">qui </ins>va être découpé
en plusieurs lignes. La première ligne sera identifiée à
l'aide d'une séquence de balises fictives. Les autres lignes
vont rester ordinaires dans la suite du paragraphe.&lt;/P&gt;
</pre>

<p>
Quand un pseudo-élément coupe un élément réel, on peut souvent
décrire l'effet désiré avec une séquence de balises fictives qui ferment
puis ré-ouvrent cet élément. Ainsi, si on balise le paragraphe de l'exemple avec
un élément SPAN :

<pre>
&lt;P&gt;<b>&lt;SPAN class="test"&gt;</b>Voici un paragraphe HTML plutôt long
qui va être découpé en plusieurs lignes.<b>&lt;/SPAN&gt;</b>
La première ligne sera identifiée à l'aide d'une séquence
de balises fictives. Les autres lignes vont rester ordinaires dans la suite du
paragraphe.&lt;/P&gt;
</pre>

L'agent utilisateur pourrait générer la séquence de balises fictives, ouvrantes et fermantes,
de façon appropriée, pour l'élément SPAN au moment d'insérer celle
du pseudo-élément :first-line.

<pre>
&lt;P&gt;&lt;P:first-line&gt;<b>&lt;SPAN class="test"&gt;</b> Voici un paragraphe
HTML plutôt long<b>&lt;/SPAN&gt;</b>&lt;/P:first-line&gt;<b>&lt;SPAN class="test"&gt;</b> qui
va être découpé en plusieurs lignes.<b>&lt;/SPAN&gt;</b> La
première ligne sera identifiée à l'aide d'une séquence de
balises fictives. Les autres lignes vont rester ordinaires dans la suite du
paragraphe.&lt;/P&gt;
</pre>

<p> Le pseudo-élément <a name="x51"><span class="index-inst" title="pseudo-elements:::first-line">:first-line</span></a>
ne peut s'attacher qu'à un élément de type bloc.

<p>
Le pseudo-élément <a name="first-line">:first-line</a> est similaire à un élément
de type en-ligne, avec certaines restrictions. Seules les propriétés suivantes peuvent
lui être appliquées : les propriétés de <a href="fonts.html#font-properties">police</a>,
les propriétés de <a href="colors.html">couleur</a>,
les propriétés d'<a href="colors.html#background-properties">arrière-plan</a>,
<a href="text.html#propdef-word-spacing" class="noxref"><span class="propinst-word-spacing">'word-spacing'</span></a>,
<a href="text.html#propdef-letter-spacing" class="noxref"><span class="propinst-letter-spacing">'letter-spacing'</span></a>,
<a href="text.html#propdef-text-decoration" class="noxref"><span class="propinst-text-decoration">'text-decoration'</span></a>,
<a href="visudet.html#propdef-vertical-align" class="noxref"><span class="propinst-vertical-align">'vertical-align'</span></a>,
<a href="text.html#propdef-text-transform" class="noxref"><span class="propinst-text-transform">'text-transform'</span></a>,
<a href="visudet.html#propdef-line-height" class="noxref"><span class="propinst-line-height">'line-height'</span></a>,
<a href="text.html#propdef-text-shadow" class="noxref"><span class="propinst-text-shadow">'text-shadow'</span></a> et
<a href="visuren.html#propdef-clear" class="noxref"><span class="propinst-clear">'clear'</span></a>.

<p><ins title="2001-08-27 id=s-5-12-1">
Dans le cas où une certaine première ligne est aussi la première d'un certain élément
de type bloc A et en même temps que l'ancêtre B de celui-ci, la séquence de balise fictive devient :</ins>
<pre>
<ins title="2001-08-27 id=s-5-12-1">&lt;B&gt;...&lt;A&gt;...&lt;B:first-line&gt;&lt;A:first-line&gt;Voici la première ligne&lt;/A:first-line&gt;&lt;/B:first-line&gt;</ins>
</pre>

<p><ins title="2001-08-27 id=s-5-12-1">
Toutes les balises fictives se trouvent dans le plus petit des élément de type bloc, l'ordre d'imbrication
des balises fictives A:first-line et B:first-line correspondant à celui des éléments A et B.</ins>

<p><ins title="2001-08-27 id=s-5-12-1">
La "première ligne mise en forme" d'un élément de type bloc correspond à la première
ligne dans le flot de l'élément, ignorant ainsi d'éventuels éléments flottants
ou en position absolue. Par exemple :</ins>

<pre class="exemple">
<ins title="2001-08-27 id=s-5-12-1">&lt;div&gt;</ins>
<ins title="2001-08-27 id=s-5-12-1">  &lt;p style="float: left"&gt;Paragraphe flottant...&lt;/p&gt;</ins>
<ins title="2001-08-27 id=s-5-12-1">  &lt;p&gt;La première ligne commence ici...&lt;/p&gt;</ins>
<ins title="2001-08-27 id=s-5-12-1">&lt;/div&gt;</ins>
</pre>

<p><ins title="2001-08-27 id=s-5-12-1">
Un sélecteur 'div:first-line' s'appliquerait à la première ligne du second paragraphe, car le
premier paragraphe se trouve en dehors du flot normal.</ins>

<h3>5.12.2 <a name="first-letter">Le pseudo-élément</a> <a name="x52"><span class="index-def" title="pseudo-elements:::first-letter|:first-letter|first-letter">:first-letter</span></a></h3>

<p>Le pseudo-élément :first-letter peut être employé pour faire des
<a name="x55"><span class="index-inst" title="initial caps">capitales initiales</span></a> et des
<a name="x56"><span class="index-inst" title="drop caps">lettrines</span></a>, ce sont des effets
typographiques courants. 
Ce genre de lettre initiale est assimilé à un élément de type en-ligne
quand la valeur de sa propriété <a href="visuren.html#propdef-float" class="noxref"><span class="propinst-float">'float'</span></a>
est 'none', et assimilé à un élément flottant autrement.

<p>
Le pseudo-élément :first-letter admet ces propriétés : les propriétés de
<a href="fonts.html#font-properties">police</a>,
les propriétés de <a href="colors.html">couleur</a>,
les propriétés d'<a href="colors.html#background-properties">arrière-plan</a>,
<a href="text.html#propdef-text-decoration" class="noxref"><span class="propinst-text-decoration">'text-decoration'</span></a>,
<a href="visudet.html#propdef-vertical-align" class="noxref"><span class="propinst-vertical-align">'vertical-align'</span></a> (seulement si la valeur de la propriété 'float' est 'none'),
<a href="text.html#propdef-text-transform" class="noxref"><span class="propinst-text-transform">'text-transform'</span></a>,
<a href="visudet.html#propdef-line-height" class="noxref"><span class="propinst-line-height">'line-height'</span></a>,
les propriétés de <a href="box.html#margin-properties">marge</a>,
les propriétés d'<a href="box.html#padding-properties">espacement</a>,
les propriétés de <a href="box.html#border-properties">bordure</a>,
<a href="visuren.html#propdef-float" class="noxref"><span class="propinst-float">'float'</span></a>,
<a href="text.html#propdef-text-shadow" class="noxref"><span class="propinst-text-shadow">'text-shadow'</span></a>
et <a href="visuren.html#propdef-clear" class="noxref"><span class="propinst-clear">'clear'</span></a>.

<div class="html-example">
<p>
Cette feuille de style produit une lettrine qui s'étend sur deux lignes :

<pre>
&lt;!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0//EN"&gt;
&lt;HTML&gt;
 &lt;HEAD&gt;
  &lt;TITLE&gt;Lettrine&lt;/TITLE&gt;
  &lt;STYLE type="text/css"&gt;
   P              { font-size: 12pt; line-height: 12pt }
   P:first-letter { font-size: 200%; font-style: italic;
                    font-weight: bold; float: left }
   SPAN           { text-transform: uppercase }
  &lt;/STYLE&gt;
 &lt;/HEAD&gt;
 &lt;BODY&gt;
  &lt;P&gt;&lt;SPAN&gt;Les premiers&lt;/SPAN&gt; mots parmi ceux d'un article
  de journal.&lt;/P&gt;
 &lt;/BODY&gt;
&lt;/HTML&gt;
</pre>

<p>Ce qui pourrait apparaître de cette manière :

<div class="figure">
<p><img src="images/first-letter.gif" alt="Illustration de l'effet combiné des pseudo-éléments :first-letter et :first-line." width="105" height="54"><span class="dlink">   <a name="img-first-letter" href="images/longdesc/first-letter-desc.html" title="Long description for drop cap example">[D]</a></span></p>
</div>

<p>La <a name="x57"><span class="index-inst" title="fictional tag sequence">séquence de balises fictives</span></a> en est :

<pre>
&lt;P&gt;
&lt;SPAN&gt;
&lt;P:first-letter&gt;
L
&lt;/P:first-letter&gt;es premiers
&lt;/SPAN&gt; 
mots parmi ceux d'un article de journal.
&lt;/P&gt;
</pre>

<p>
Noter que les balises du pseudo-élément :first-letter (c.à.d., le premier caractère)
viennent buter contre le contenu, alors que la balise ouvrante du pseudo-élément :first-line
s'insère juste après celle ouvrante de l'élément auquel il est accolé.

</div>

<p>
Pour obtenir le formatage des lettrines traditionnelles, les agents utilisateurs peuvent approcher les
tailles des polices, par exemple dans l'alignement des lignes de base. Le contour des glyphes peut
aussi intervenir dans le formatage.

<p>
Les caractères de ponctuation (c.à.d. les caractères définis en Unicode
<a href="refs.html#ref-UNICODE" rel="biblioentry" class="noxref"><span class="normref">[UNICODE]</span></a>
dans les classes de ponctuation "open" (Ps), "close" (Pe) et "other" (Po) ) qui précèdent
la première lettre devraient également être pris en compte, comme ici :

<div class="figure">
<p><img src="images/first-letter2.gif" alt="Les guillemets initiaux devraient être pris en compte par :first-letter." width="114" height="72"><span class="dlink">   <a name="img-first-letter2" href="images/longdesc/first-letter2-desc.html" title="Long description for punctuation and drop cap example">[D]</a></span></p>
</div>

<p>
Le pseudo-élément :first-letter ne peut correspondre qu'avec une partie
d'un élément de type <a href="visuren.html#block-level">bloc</a>.

<p>
Certaines combinaisons de lettres, dans une langue donnée, peuvent obéir à des
règles particulières. En hollandais, par exemple, quand la combinaison "ij" survient
au début d'un mot, le pseudo-élément :first-letter devrait les prendre en compte
ensemble.

<div class="example"><p style="display:none">Exemple(s) :
<p>
<a name="overlapping-example">L'exemple suivant</a> illustre l'interaction de pseudo-éléments
qui sont enchevêtrés. La première lettre de chacun des éléments P sera verte et aura
une taille de police de '24pt'. La suite de cette première ligne sera bleue, le reste des lignes du paragraphe
sera rouge.

<pre>
P { color: red; font-size: 12pt }
P:first-letter { color: green; font-size: 200% }
P:first-line { color: blue }

&lt;P&gt;Voici un morceau de texte qui est formaté sur deux lignes.&lt;/P&gt;
</pre>

<p>
En supposant qu'un retour à la ligne survient avant le mot "sur", la
<a name="x58"><span class="index-inst" title="fictional tag sequence">séquence de balises fictives</span></a>
en serait :

<pre>
&lt;P&gt;
&lt;P:first-line&gt;
&lt;P:first-letter&gt; 
V 
&lt;/P:first-letter&gt;oici un morceau de texte qui est formaté
&lt;/P:first-line&gt; 
sur deux lignes. 
&lt;/P&gt;
</pre>

<p>
Noter que l'élément P:first-letter se tient à l'intérieur de l'élément
P:first-line. Le pseudo-élément :first-letter hérite des propriétés
appliquées au pseudo-élément :first-line, cependant, si on lui spécifie une même
propriété, c'est la valeur de cette dernière qui sera retenue.
</div>

<h3>5.12.3 <a name="before-and-after">Les pseudo-éléments</a> <a name="x59"><span class="index-def" title="pseudo-elements:::before|:before">:before</span></a> et <a name="x61"><span class="index-def" title="pseudo-elements:::after|:after">:after</span></a></h3>

<p>Les pseudo-élément ':before' et ':after' servent à insérer un contenu
généré avant ou après celui d'un élément.
Le chapitre sur le <a href="generate.html">texte généré</a> en donne une explication.

<div class="example"><p style="display:none">Exemple(s) :
<p>
<pre>
H1:before {content: counter(chapno, upper-roman) ". "}
</pre>
</div>

<p>
Combinés aux pseudo-éléments :before et :after, le pseudo-élément :first-letter, ou :first-line,
s'applique à la première lettre, ou à la première ligne, de l'élément, y compris le texte inséré.

<div class="example"><p style="display:none">Exemple(s) :
<p>
<pre>
P.special:before {content: "Spécial !"}
P.special:first-letter {color: gold}
</pre>

<p>Ceci donnera une couleur or au "S" de "Spécial !".
</div>

<hr class="navbar">

<div class="navbar" align="center">
<p><a href="syndata.html">précédent</a>  
<a href="cascade.html">suivant</a>  
<a href="cover.html#minitoc">sommaire</a>  
<a href="propidx.html">propriétés</a>  
<a href="indexlist.html">index</a>  
</div>
</body>
</html>